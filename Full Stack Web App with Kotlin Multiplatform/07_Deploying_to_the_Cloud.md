# Preparing for deployment

In order to get our application running on managed infrastructure (such as cloud providers) we need to integrate our application with the environment variables provided by the platform of our choice, and add any other required configuration to our project. Specifically, we are going to look at how to pass the application port and MongoDB connection string.

#### The PORT variable

On managed platforms, the port on which the application should run is often determined externally, and exposed through the `PORT` environment variable. If present, we can respect this setting by configuring our `embeddedServer` in `src/jvmMain/kotlin/Server.kt` like this:

```kotlin
fun main() {
    val port = System.getenv("PORT")?.toInt() ?: 9090
    embeddedServer(Netty, port) {
    // . . .
```

#### The MONGODB_URI variable

Managed platforms also often expose connection strings through environment variables – for MongoDB, this can be the `MONGODB_URI` String, which needs to be used by our client to connect to the database. Depending on the specific MongoDB instance we might try to connect to, we might need to also append the `retryWrites=false` parameter to our connection string.

To properly wire up these requirements, we instantiate our `client` and `database` variables in `src/jvmMain/kotlin/Server.kt` like so:

```kotlin
val connectionString: ConnectionString? = System.getenv("MONGODB_URI")?.let {
    ConnectionString("$it?retryWrites=false")
}

val client = if (connectionString != null) KMongo.createClient(connectionString).coroutine else KMongo.createClient().coroutine
val database = client.getDatabase(connectionString?.database ?: "shoppingList")
```

This ensures that whenever our environment variables are set, we create our `client` based on this information. Otherwise (e.g. on localhost), we instantiate our database connection just as we did previously.

#### The Procfile

Managed cloud platforms like Heroku, or PaaS implementations like [Dokku](https://github.com/dokku/dokku) also handle the life cycle of your application, and as such require a definition of an "entry point". The examples named above use a file called `Procfile` in the project root directory. It should point to the output generated by our `stage` task (which is included in the Gradle template already):

```
web: ./build/install/shoppingList/bin/shoppingList
```

#### Turning on production mode

To turn on compilation with optimizations for our JavaScript assets, we need to pass another flag to our build process: `ORG_GRADLE_PROJECT_isProduction` should be set to `true`. When we are deploying our application to our target environment, simply we can set this environment variable.

**You can also find the finished application on GitHub on the [`final` branch](https://github.com/kotlin-hands-on/jvm-js-fullstack/tree/final).**

At this point, it's time we move on without further guidance – but that doesn't mean we should stop experimenting! Check out the "What's next" section to find some inspiration for what else could be done with the project.

#### Allowing to access the database

During the application deployment, possibly the firewall rules should be changed to allow the application to access the database. More details are available at [MongoDB docs](https://docs.atlas.mongodb.com/security/ip-access-list/)

### Relevant Gradle configuration

The `stage` task is an alias for `installDist`:

```kotlin
// Alias "installDist" as "stage" (for cloud providers)
tasks.create("stage") {
    dependsOn(tasks.getByName("installDist"))
}

// only necessary until https://youtrack.jetbrains.com/issue/KT-37964 is resolved
distributions {
    main {
        contents {
            from("$buildDir/libs") {
                rename("${rootProject.name}-jvm", rootProject.name)
                into("lib")
            }
        }
    }
}
```
